<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>内容区</title>
    <link rel="stylesheet" href="css/content-one.css">
    <link rel="stylesheet" href="font/ic/css/all.css">
</head>
<script type="text/javascript" src="js/index.js"></script>
<body>
<div id="div1">
<div id="header">
    <div class="head">
        <div class="left">harmonit</div>
        <div class="right">
            <div class="r-one">首页</div>
            <div class="r-two">分类</div>
            <div class="r-three">标签</div>
            <div class="r-four">关于</div>
            <div class="r-pic"></div>
        </div>
    </div>
    <div class="h-title">
        <span>此处是标题</span>
    </div>
</div>

<div id="content">
    <div class="center">
        1.1 存在的问题

        对于容器镜像使用者

        问题一：启动容器慢：容器启动慢的情况普遍发生在当用户启动一个很大的容器镜像时，由于在容器准备阶段需要三步（以overlayfs为例）：

        下载镜像

        解压镜像

        使用overlayfs将容器可写层和镜像中的只读层聚合起来提供容器运行环境

        其中，下载镜像阶段需要下载整个镜像文件，不能实现文件数据按需加载。再加上下载镜像本身受限于网络带宽，当容器镜像达到GB级别时，下载时间会较长，破坏了容器原本优秀的用户体验。

        问题二：较高的本地存储成本：不同镜像之间可以共享的最小单位是镜像中的层，缺点之一是重复数据的处理效率较低。原因如下：

        首先，层内部存在重复的数据

        其次，层与层之间可能存在大量重复的数据，即使有微小的差别，也会被作为不同的层

        再次，根据 OCI imagespec 对删除文件和 hardlink 的设计，镜像内部已经被上层删除的文件可能仍然存在于下层，并包含在镜像中

        对于镜像提供者

        这里的提供者主要指容器服务的镜像中心。

        问题一：巨大的存储资源浪费

        存在大量相似镜像，造成这种情况有两个原因：

        首先，上面提到的层的缺点，导致在容器镜像中心存在许多相似镜像；

        其次，OCI image 使用了 tar+gzip 格式来表示镜像中的层，而 tar 格式并不区分 tar archive entries ordering，这带来一个问题，如果用户在不同机器上 build 同一个镜像，最终可能会因为使用了不同的文件系统而得到不同的镜像，用户上传之后，镜像中心中会存在若干不同镜像的实质内容是完全相同的情况。

        镜像去重效率低

        虽然镜像中心有垃圾回收机制来实现去重功能，但其仍然以层为单位，所以只能在有完全相同hash value 的层之间去重。

        问题二：云原生软件供应链带来的新需求

        随着时间推移，和软件供应链一起发展的还有对软件供应链环节的多样性攻击手段。安全防护是软件供应链中非常重要的组成，不光体现在对软件本身的安全增强，也体现在对供应链的安全增强。因为应用运行环境被前置到了容器镜像中，所以对容器镜像的安全，包括对镜像的漏洞扫描和签名成为了容器服务提供者的必要能力。

        OCI 镜像规范的缺陷

        主要的缺陷有两点：

        tar格式标准

        tar格式并不区分tar archive entries ordering，这带来一个问题，即如果用户在不同机器上 ；build 同一个镜像，最终可能会因为使用了不同的文件系统而得到不同的镜像，比如在文件系统A 上的 order 是 foo 在 bar 之前进入 tar，在文件系统 B 上的 order 是 bar 在 foo 之前进入tar，那么这两个镜像是不同的；

        当 tar 被 gzip 压缩过之后不支持 seek，导致运行之前必须先下载并解压 targz 的 image layers，而不能实现文件数据按需加载。

        以层为镜像的基本单位
    </div>
    <div class="c-left">
        1.1 存在的问题

        对于容器镜像使用者

        问题一：启动容器慢：容器启动慢的情况普遍发生在当用户启动一个很大的容器镜像时，由于在容器准备阶段需要三步（以overlayfs为例）：

        下载镜像

        解压镜像

        使用overlayfs将容器可写层和镜像中的只读层聚合起来提供容器运行环境

        其中，下载镜像阶段需要下载整个镜像文件，不能实现文件数据按需加载。再加上下载镜像本身受限于网络带宽，当容器镜像达到GB级别时，下载时间会较长，破坏了容器原本优秀的用户体验。

        问题二：较高的本地存储成本：不同镜像之间可以共享的最小单位是镜像中的层，缺点之一是重复数据的处理效率较低。原因如下：

    </div>
</div>
</div>
</body>
</html>